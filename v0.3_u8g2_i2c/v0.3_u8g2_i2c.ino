#include <Arduino_LSM9DS1.h>
#include <Arduino.h>
#include <U8g2lib.h>

#ifdef U8X8_HAVE_HW_SPI
#include <SPI.h>
#endif
#ifdef U8X8_HAVE_HW_I2C
#include <Wire.h>
#endif
U8G2_SH1106_128X64_NONAME_1_HW_I2C u8g2(U8G2_R0, /* reset=*/ U8X8_PIN_NONE);


float accelX,            accelY,             accelZ,            // units m/s/s i.e. accelZ if often 9.8 (gravity)
      gyroX,             gyroY,              gyroZ,             // units dps (degrees per second)
      gyroDriftX,        gyroDriftY,         gyroDriftZ,        // units dps
      gyroRoll,          gyroPitch,          gyroYaw,           // units degrees (expect major drift)
      gyroCorrectedRoll, gyroCorrectedPitch, gyroCorrectedYaw,  // units degrees (expect minor drift)
      accRoll,           accPitch,           accYaw,            // units degrees (roll and pitch noisy, yaw not possible)
      complementaryRoll, complementaryPitch, complementaryYaw;  // units degrees (excellent roll, pitch, yaw minor drift)

long lastTime;
long lastInterval;

int directions, angles, temps(0), acceleration, acc;

unsigned long temperature_timer = millis();
//float angles_offset;

static unsigned char bmpdata[] PROGMEM = {
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3C, 0x38, 0x00, 0x00, 0x00, 0x80, 0x07, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x80, 0x07, 0x00, 0x3E, 0x7C, 0x00, 0x00, 0x00, 0xC0, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC0, 0x0F, 0x00, 0x1F, 0x7C, 0x00, 0x00, 0x00, 0xE0, 0x07, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0xC0, 0x1F, 0x00, 0x0F, 0x7E, 0x00, 0x00, 0x00, 0xF0, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF0, 0x1F, 0x80, 0x07, 0x7F, 0x00, 0x00, 0x00, 0xF0, 0x03, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0xF8, 0x0F, 0xC0, 0x83, 0x0F, 0x00, 0x00, 0x00, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFC, 0x0F, 0xC0, 0x81, 0x03, 0x00, 0x00, 0x00, 0x7C, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0xFE, 0x07, 0xF0, 0xC0, 0x01, 0x00, 0x00, 0x00, 0x1E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xEF, 0x07, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x80, 0xF7, 0x07, 0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC0, 0xF3, 0x03, 0x3E, 0x3E, 0x00, 0x00, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0xE0, 0xF9, 0x03, 0x1E, 0x3E, 0xC0, 0x03, 0xFF, 0x00, 0x00, 0x00, 0xFC, 0x00, 0x00, 0x00, 0x00, 0xF0, 0xF9, 0x03, 0x1F, 0x7F, 0xE0, 0xC7, 0xFF, 0xE1, 0x01, 0x00, 0xFF, 0x01, 0x00, 
0x00, 0x00, 0xF8, 0xFC, 0xC1, 0xCF, 0x3F, 0xF0, 0xFF, 0xFF, 0xE1, 0x03, 0xF0, 0xFF, 0x01, 0x00, 0x00, 0x00, 0xFC, 0xFC, 0xC1, 0xFF, 0x3F, 0xFC, 0xFF, 0xFF, 0xF1, 0x03, 0xFC, 0xFF, 0x01, 0x00, 
0x00, 0x00, 0x7C, 0xFC, 0xE0, 0xFB, 0x3F, 0xFE, 0xFF, 0xFF, 0xFC, 0x03, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x3E, 0xFC, 0xF0, 0xFF, 0x1F, 0xFF, 0xFF, 0x7F, 0xFE, 0xC1, 0xFF, 0x7F, 0x00, 0x00, 
0x00, 0x00, 0x3F, 0x7E, 0xF8, 0xFD, 0xCF, 0xF9, 0xDF, 0x3F, 0xFF, 0xF0, 0x7F, 0x7C, 0x00, 0x00, 0x00, 0x80, 0x1F, 0x7E, 0xFC, 0xF8, 0xE7, 0xFC, 0xE7, 0x9F, 0xFF, 0xFC, 0x3F, 0x3C, 0x00, 0x00, 
0x00, 0x80, 0x1F, 0x7F, 0x7C, 0xF8, 0x7F, 0xFE, 0xF3, 0x8F, 0x7F, 0xFE, 0x87, 0x1F, 0x00, 0x00, 0x00, 0xC0, 0x0F, 0x3F, 0x7E, 0xFE, 0x3F, 0xFF, 0xF9, 0xC3, 0x3F, 0xFF, 0xC1, 0x1F, 0x00, 0x00, 
0x00, 0xE0, 0x8F, 0x3F, 0x3F, 0xFF, 0x8F, 0x7F, 0xFE, 0xE3, 0x9F, 0xFF, 0xF0, 0x0F, 0x00, 0x00, 0x00, 0xF0, 0x8F, 0x9F, 0xBF, 0xFF, 0xC7, 0x3F, 0xFF, 0xF1, 0xFF, 0x3F, 0xF8, 0x0F, 0x18, 0x00, 
0x00, 0xF0, 0xC7, 0xDF, 0x9F, 0xFF, 0xE1, 0x9F, 0xFF, 0xF1, 0xFF, 0x0F, 0xFE, 0x07, 0x3E, 0x00, 0x00, 0xF8, 0xC3, 0xCF, 0xCF, 0xFF, 0xF0, 0xCF, 0xFF, 0xFB, 0xF7, 0x87, 0xFF, 0x03, 0xFF, 0x00, 
0x00, 0xFC, 0xC3, 0xFF, 0xE7, 0x7F, 0xF8, 0xC7, 0xFF, 0xFF, 0xF3, 0xC3, 0xFF, 0xF3, 0xFF, 0x00, 0x00, 0xFC, 0xE1, 0xFF, 0xE3, 0x1F, 0xFC, 0xC3, 0xFF, 0xFF, 0xF3, 0xFF, 0xFD, 0xFF, 0x3F, 0x00, 
0x00, 0xFE, 0xE1, 0xFF, 0xF3, 0x0F, 0xFC, 0x81, 0xFF, 0xFF, 0xF1, 0xFF, 0xFC, 0xFF, 0x03, 0x00, 0x00, 0xFE, 0xE0, 0xFF, 0xE1, 0x07, 0xF8, 0x01, 0xBF, 0xFF, 0xF0, 0x3F, 0xFE, 0x3F, 0x00, 0x00, 
0x00, 0xFF, 0xF0, 0xFF, 0xC0, 0x00, 0x70, 0x00, 0xCE, 0x7F, 0xF0, 0x0F, 0xFE, 0x07, 0x00, 0x00, 0x00, 0x3E, 0xF0, 0x7F, 0x00, 0x00, 0x60, 0x00, 0xE0, 0x3F, 0xE0, 0x07, 0x7E, 0x00, 0x00, 0x00, 
0x00, 0x0C, 0xF0, 0x3F, 0x00, 0x00, 0x00, 0x00, 0xF0, 0x1F, 0xC0, 0x01, 0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE0, 0x1F, 0x00, 0x00, 0x00, 0x00, 0xF8, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0xC0, 0x01, 0x00, 0x00, 0x00, 0x00, 0xFE, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xFF, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF0, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE0, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
};



void setup() {
  u8g2.begin();
  //u8g2.clearBuffer();          // clear the internal memory
  u8g2.firstPage();
   do {
        u8g2.drawXBMP( 0, 0, 128, 64, bmpdata);
  } while( u8g2.nextPage() );
  if (!IMU.begin()) {
    //Serial.println("Failed to initialize IMU!");
    while (1);
  }
  calibrateIMU(250, 250);
  lastTime = micros();
  delay(2000);
}

//----------------------------------------------CALIBLRATION
void calibrateIMU(int delayMillis, int calibrationMillis) { 
  int calibrationCount = 0;
  delay(delayMillis); // to avoid shakes after pressing reset button
  float sumX, sumY, sumZ;
  int startTime = millis();
  while (millis() < startTime + calibrationMillis) {
    if (readIMU()) {
      // in an ideal world gyroX/Y/Z == 0, anything higher or lower represents drift
      sumX += gyroX;
      sumY += gyroY;
      sumZ += gyroZ;

      calibrationCount++;
    }
  }
  if (calibrationCount == 0) {
    //Serial.println("Failed to calibrate");
  }
  gyroDriftX = sumX / calibrationCount;
  gyroDriftY = sumY / calibrationCount;
  gyroDriftZ = sumZ / calibrationCount;
}

//----------------------------------------------LIRE INFO
bool readIMU() {
  if (IMU.accelerationAvailable() && IMU.gyroscopeAvailable() ) {
    IMU.readAcceleration(accelX, accelY, accelZ);
    IMU.readGyroscope(gyroX, gyroY, gyroZ); 
//    if(millis() < 2500){
//      accPitch = atan2(-accelX, sqrt(accelY * accelY + accelZ * accelZ)) * 180 / M_PI;
//      angles_offset = accPitch;  
//    }
    return true;
  }
  return false;
}
//----------------------------------------------MAIN
void loop() {

  angles = complementaryPitch; 
  acceleration = complementaryRoll;
  u8g2.firstPage();
  do {
    //----------------------------------------------UPDATE DES INFOS ET CALCULER L'ANGLE ACTUEL
    if (readIMU()) {
      long currentTime = micros();
      lastInterval = currentTime - lastTime; // expecting this to be ~104Hz +- 4%
      lastTime = currentTime;
      doCalculations();       
    }    
    //----------------------------------------------DIRECTIONS
    if(complementaryPitch > 0){
      directions = 1;//gauche
    }
    else if (complementaryPitch < 0){
      directions = 0;//droite
    }   
    //----------------------------------------------CONVERTION ANGLES    
    angles = sqrt(pow(angles, 2)); // Toujours positif
    //----------------------------------------------FLÃˆCHE
    if(directions == 0 && int(angles) > 2){//Fleche a gauche
      u8g2.drawTriangle(24,30, 42,18, 42,38);//triangle
    }
    else if(directions == 1 && int(angles) > 2){//Fleche a droite
      u8g2.drawTriangle(116,30, 98,18, 98,38);//triangle
    }    
    //----------------------------------------------AFFICHAGE ANGLE
    u8g2.setFont(u8g2_font_helvB24_tn);
    u8g2.setCursor(47,40);
    if(int(angles) < 10){ //afficher un 0 avant le chiffre 
        u8g2.print("0");   //si le chiffre est en 0 et 9
    }
    u8g2.print(int(angles));
    u8g2.setFont(u8g2_font_helvB24_tf);
    u8g2.write(0xB0);//afficher le signe degree
    //----------------------------------------------TEMPERATURE                                     
    u8g2.setFont(u8g2_font_5x7_tf); //police
    u8g2.setCursor(0, 7);
    if(millis()>temperature_timer+5000){  //timer pour que la temperature se refresh a chaque seconde
      temps = IMU.readTemp(); //Lecture temperature du mpu
      temperature_timer = millis();
    }
    u8g2.print(temps);
    u8g2.write(0xB0);//afficher le signe degree  
    u8g2.print("C");         
    //----------------------------------------------GAUGE_INCLINAISON
    u8g2.drawBox(64,50, 4,14);//ligne au millieu
    if(directions == 0 && angles>2){ //bar si penche a gauche
      if(angles < 48){
        u8g2.drawBox((62-angles),52, angles,10);
      }
      else{                  
        u8g2.drawBox (12,52, 50,10);
      }
    }
    else if(directions == 1 && angles>2 ){//bar si penche a droite
      if(angles < 47){
        u8g2.drawBox(70,52,angles,10);
      }
      else{
        u8g2.drawBox(70,52, 46,10);
      }
    } 
    //-----------------------------------------------ACCELERATION                
    if(complementaryRoll < 0){//acceleration
      acc = 0;
    }
    else if(complementaryRoll >= 0){//deceleration
      acc = 1;  
    }
    acceleration = sqrt(pow(acceleration, 2));  
    //-----------------------------------------------LIGNE ACCELERATION              
    u8g2.drawBox(118,60, 10,4);
    if(acceleration > 1 && acc == 1){                
      u8g2.drawBox(121,(62-acceleration), 4,acceleration);
    }
    //-----------------------------------------------LIGNE DECELERATION  
    u8g2.drawBox(0,60, 10,4);
    if(acceleration > 1 && acc == 0){                
      u8g2.drawBox(3,(62-acceleration), 4,acceleration);
    }
    
    //-----------------------------------------------    
  } while ( u8g2.nextPage() );
  
}

//----------------------------------------------CALCULER L'ANGLE 
bool flag = 0;
void doCalculations() {
  accRoll = atan2(accelY, accelZ) * 180 / M_PI;
  accPitch = atan2(-accelX, sqrt(accelY * accelY + accelZ * accelZ)) * 180 / M_PI;
  //gyroPitch = gyroPitch - angles_offset;
  float lastFrequency = (float) 1000000.0 / lastInterval;
  gyroRoll = gyroRoll + (gyroX / lastFrequency);
  gyroPitch = gyroPitch + (gyroY / lastFrequency);
  gyroYaw = gyroYaw + (gyroZ / lastFrequency);

  gyroCorrectedRoll = gyroCorrectedRoll + ((gyroX - gyroDriftX) / lastFrequency);
  gyroCorrectedPitch = gyroCorrectedPitch + ((gyroY - gyroDriftY) / lastFrequency);
  gyroCorrectedYaw = gyroCorrectedYaw + ((gyroZ - gyroDriftZ) / lastFrequency);

  complementaryRoll = complementaryRoll + ((gyroX - gyroDriftX) / lastFrequency);
  complementaryPitch = complementaryPitch + ((gyroY - gyroDriftY) / lastFrequency);
  complementaryYaw = complementaryYaw + ((gyroZ - gyroDriftZ) / lastFrequency);
  
  //gyroCorrectedPitch = gyroCorrectedPitch - angles_offset;
  
  complementaryRoll = 0.95 * complementaryRoll + 0.05 * accRoll;
  complementaryPitch = 0.95 * complementaryPitch + 0.05 * accPitch;
}
