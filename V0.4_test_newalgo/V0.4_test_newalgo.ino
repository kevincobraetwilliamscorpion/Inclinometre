/*Source pour la corélation entre accélérometre et gyroscope

  Exemple pour utiliser un accelerometre pour trouver inclinaison mais probleme lors d'un mouvement
  https://www.youtube.com/watch?v=USa3HFLnrlk&t
  https://www.instructables.com/DIY-Digital-Spirit-Level/

  Exemple qui démontre comment utiliser acc et gyro ensemble
  https://www.youtube.com/watch?v=XCyRXMvVSCw&t
  https://dronebotworkshop.com/mpu-6050-level/

  Exemple qui démontre comment utiliser acc et gyro ensemble
  https://www.youtube.com/watch?v=UxABxSADZ6U.

  Théorique du pourquoi il utilise l'acc et le gyro ensemble !
  https://www.posital.com/fr/produits/inclinometres/mems/MEMS-Technology.php
*/

#include <ArduinoBLE.h>
#include <Arduino_LSM9DS1.h>
#include <Arduino.h>
#include <U8g2lib.h>
//Parametre

#define Acceleration_offset 50//sensibiliter de l'accelerometre

//OLED setup i2c
#ifdef U8X8_HAVE_HW_SPI
#include <SPI.h>
#endif
#ifdef U8X8_HAVE_HW_I2C
#include <Wire.h>
#endif
U8G2_SH1106_128X64_NONAME_1_HW_I2C u8g2(U8G2_R0, /* reset=*/ U8X8_PIN_NONE);

//Bluetooth setup
BLEService accelerometerService("19b10000-e8f2-537e-4f6c-d104768a1214");
BLEStringCharacteristic firstCharacteristic("19b10010-e8f2-537e-4f6c-d104768a1214",  // standard 16-bit characteristic UUID
    BLERead | BLENotify, 50); // remote clients will be able to get notifications if this characteristic changes
String oldAcclerometerReading = "0";

//Variable Globale
float accelX,            accelY,             accelZ,            // units m/s/s i.e. accelZ if often 9.8 (gravity)
      gyroX,             gyroY,              gyroZ,             // units dps (degrees per second)
      gyroDriftX,        gyroDriftY,         gyroDriftZ,        // units dps
      gyroRoll,          gyroPitch,          gyroYaw,           // units degrees (expect major drift)
      gyroCorrectedRoll, gyroCorrectedPitch, gyroCorrectedYaw,  // units degrees (expect minor drift)
      accRoll,           accPitch,           accYaw,            // units degrees (roll and pitch noisy, yaw not possible)
      complementaryRoll, complementaryPitch, complementaryYaw;  // units degrees (excellent roll, pitch, yaw minor drift)

long lastTime;
long lastInterval;

int directions, angles, temps, acceleration, acc, angles_max(0), offset_angles_pitch(0);
float offset_acc(0);
//Timer
unsigned long temperature_timer = millis();
unsigned long acc_angle = millis();

//LOGO Ninja
static unsigned char ninjalogo[] PROGMEM = {
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3C, 0x38, 0x00, 0x00, 0x00, 0x80, 0x07, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x80, 0x07, 0x00, 0x3E, 0x7C, 0x00, 0x00, 0x00, 0xC0, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC0, 0x0F, 0x00, 0x1F, 0x7C, 0x00, 0x00, 0x00, 0xE0, 0x07, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0xC0, 0x1F, 0x00, 0x0F, 0x7E, 0x00, 0x00, 0x00, 0xF0, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF0, 0x1F, 0x80, 0x07, 0x7F, 0x00, 0x00, 0x00, 0xF0, 0x03, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0xF8, 0x0F, 0xC0, 0x83, 0x0F, 0x00, 0x00, 0x00, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFC, 0x0F, 0xC0, 0x81, 0x03, 0x00, 0x00, 0x00, 0x7C, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0xFE, 0x07, 0xF0, 0xC0, 0x01, 0x00, 0x00, 0x00, 0x1E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xEF, 0x07, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x80, 0xF7, 0x07, 0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC0, 0xF3, 0x03, 0x3E, 0x3E, 0x00, 0x00, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0xE0, 0xF9, 0x03, 0x1E, 0x3E, 0xC0, 0x03, 0xFF, 0x00, 0x00, 0x00, 0xFC, 0x00, 0x00, 0x00, 0x00, 0xF0, 0xF9, 0x03, 0x1F, 0x7F, 0xE0, 0xC7, 0xFF, 0xE1, 0x01, 0x00, 0xFF, 0x01, 0x00,
  0x00, 0x00, 0xF8, 0xFC, 0xC1, 0xCF, 0x3F, 0xF0, 0xFF, 0xFF, 0xE1, 0x03, 0xF0, 0xFF, 0x01, 0x00, 0x00, 0x00, 0xFC, 0xFC, 0xC1, 0xFF, 0x3F, 0xFC, 0xFF, 0xFF, 0xF1, 0x03, 0xFC, 0xFF, 0x01, 0x00,
  0x00, 0x00, 0x7C, 0xFC, 0xE0, 0xFB, 0x3F, 0xFE, 0xFF, 0xFF, 0xFC, 0x03, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x3E, 0xFC, 0xF0, 0xFF, 0x1F, 0xFF, 0xFF, 0x7F, 0xFE, 0xC1, 0xFF, 0x7F, 0x00, 0x00,
  0x00, 0x00, 0x3F, 0x7E, 0xF8, 0xFD, 0xCF, 0xF9, 0xDF, 0x3F, 0xFF, 0xF0, 0x7F, 0x7C, 0x00, 0x00, 0x00, 0x80, 0x1F, 0x7E, 0xFC, 0xF8, 0xE7, 0xFC, 0xE7, 0x9F, 0xFF, 0xFC, 0x3F, 0x3C, 0x00, 0x00,
  0x00, 0x80, 0x1F, 0x7F, 0x7C, 0xF8, 0x7F, 0xFE, 0xF3, 0x8F, 0x7F, 0xFE, 0x87, 0x1F, 0x00, 0x00, 0x00, 0xC0, 0x0F, 0x3F, 0x7E, 0xFE, 0x3F, 0xFF, 0xF9, 0xC3, 0x3F, 0xFF, 0xC1, 0x1F, 0x00, 0x00,
  0x00, 0xE0, 0x8F, 0x3F, 0x3F, 0xFF, 0x8F, 0x7F, 0xFE, 0xE3, 0x9F, 0xFF, 0xF0, 0x0F, 0x00, 0x00, 0x00, 0xF0, 0x8F, 0x9F, 0xBF, 0xFF, 0xC7, 0x3F, 0xFF, 0xF1, 0xFF, 0x3F, 0xF8, 0x0F, 0x18, 0x00,
  0x00, 0xF0, 0xC7, 0xDF, 0x9F, 0xFF, 0xE1, 0x9F, 0xFF, 0xF1, 0xFF, 0x0F, 0xFE, 0x07, 0x3E, 0x00, 0x00, 0xF8, 0xC3, 0xCF, 0xCF, 0xFF, 0xF0, 0xCF, 0xFF, 0xFB, 0xF7, 0x87, 0xFF, 0x03, 0xFF, 0x00,
  0x00, 0xFC, 0xC3, 0xFF, 0xE7, 0x7F, 0xF8, 0xC7, 0xFF, 0xFF, 0xF3, 0xC3, 0xFF, 0xF3, 0xFF, 0x00, 0x00, 0xFC, 0xE1, 0xFF, 0xE3, 0x1F, 0xFC, 0xC3, 0xFF, 0xFF, 0xF3, 0xFF, 0xFD, 0xFF, 0x3F, 0x00,
  0x00, 0xFE, 0xE1, 0xFF, 0xF3, 0x0F, 0xFC, 0x81, 0xFF, 0xFF, 0xF1, 0xFF, 0xFC, 0xFF, 0x03, 0x00, 0x00, 0xFE, 0xE0, 0xFF, 0xE1, 0x07, 0xF8, 0x01, 0xBF, 0xFF, 0xF0, 0x3F, 0xFE, 0x3F, 0x00, 0x00,
  0x00, 0xFF, 0xF0, 0xFF, 0xC0, 0x00, 0x70, 0x00, 0xCE, 0x7F, 0xF0, 0x0F, 0xFE, 0x07, 0x00, 0x00, 0x00, 0x3E, 0xF0, 0x7F, 0x00, 0x00, 0x60, 0x00, 0xE0, 0x3F, 0xE0, 0x07, 0x7E, 0x00, 0x00, 0x00,
  0x00, 0x0C, 0xF0, 0x3F, 0x00, 0x00, 0x00, 0x00, 0xF0, 0x1F, 0xC0, 0x01, 0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE0, 0x1F, 0x00, 0x00, 0x00, 0x00, 0xF8, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0xC0, 0x01, 0x00, 0x00, 0x00, 0x00, 0xFE, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xFF, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF0, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE0, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
};
/*-------------------------------------------------------------------------------------------------------------*//*-------------------------------------------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------------------------------------------*//*-------------------------------------------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------------------------------------------*//*-------------------------------------------------------------------------------------------------------------*/
void setup() {
  u8g2.begin(); 
  u8g2.firstPage();
  do {
    u8g2.drawXBMP( 0, 0, 128, 64, ninjalogo);
  } while ( u8g2.nextPage() );

  if (!IMU.begin()) {//Demarage Capteur
    //Serial.println("Failed to initialize IMU!");
    while (1);
  }

  if (!BLE.begin()) { //Demarrage Bluetooth
    //Serial.println("Starting BLE failed!");
    while (1);
  }
  //Setup Bluetooth
  BLE.setLocalName("Accelerometer");//Nom lors de la connection
  BLE.setAdvertisedService(accelerometerService); // add the service UUID
  accelerometerService.addCharacteristic(firstCharacteristic); // add the characteristic
  BLE.addService(accelerometerService); // Add the service
  firstCharacteristic.writeValue(oldAcclerometerReading); // set initial value for this characteristic
  BLE.advertise();

  calibrateIMU(250, 250);//Calibration du Gyroscope
  getoffset();
  lastTime = micros();
  delay(2500);
}
/*-------------------------------------------------------------------------------------------------------------*//*-------------------------------------------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------------------------------------------*//*-------------------------------------------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------------------------------------------*//*-------------------------------------------------------------------------------------------------------------*/
void loop() {
  BLEDevice central = BLE.central();

  angles = complementaryPitch;//angles utiliser lors de l'affichage
  acceleration = accelY * Acceleration_offset;//ajuster la sensibilite de l'acc
  
  u8g2.firstPage();
  do {
    //----------------------------------------------UPDATE DES INFOS ET CALCULER L'ANGLE ACTUEL
    if (readIMU()) {
      long currentTime = micros();
      lastInterval = currentTime - lastTime; // expecting this to be ~104Hz +- 4%
      lastTime = currentTime;
      doCalculations();
    }
    //----------------------------------------------DIRECTIONS
    if (complementaryPitch > 0) {
      directions = 1;//gauche
    }
    else if (complementaryPitch < 0) {
      directions = 0;//droite
    }
    //----------------------------------------------CONVERTION ANGLES
    angles = sqrt(pow(angles, 2)); // Toujours positif
    //----------------------------------------------FLÈCHE
    if (directions == 0 && int(angles) > 2) { //Gauche
      u8g2.drawTriangle(24, 30, 42, 18, 42, 38); //triangle
    }
    else if (directions == 1 && int(angles) > 2) { //Droite
      u8g2.drawTriangle(116, 30, 98, 18, 98, 38); //triangle
    }
    //----------------------------------------------AFFICHAGE ANGLE
    u8g2.setFont(u8g2_font_helvB24_tn);
    u8g2.setCursor(47, 40);
    if (int(angles) < 10) { //afficher un 0 avant le chiffre
      u8g2.print("0");   //si le chiffre est en 0 et 9
    }
    u8g2.print(int(angles));
    u8g2.setFont(u8g2_font_helvB24_tf);
    u8g2.write(0xB0);//afficher le signe degree
    //----------------------------------------------TEMPERATURE
    u8g2.setFont(u8g2_font_5x7_tf); //police
    u8g2.setCursor(0, 7);
    if (millis() > temperature_timer + 5000) { //timer pour que la temperature se refresh a chaque seconde
      temps = IMU.readTemp(); //Lecture temperature du mpu
      temperature_timer = millis();
    }
    u8g2.print(temps);
    u8g2.write(0xB0);//afficher le signe degree
    u8g2.print("C");
    //----------------------------------------------AFFICHAGE ANGLE MAXIMUM
    u8g2.setFont(u8g2_font_5x7_tf); //police
    u8g2.setCursor(0, 15);
    u8g2.print("MAX:");
    if (angles > angles_max) {
      angles_max = angles;
    }
    if (angles_max < 10) { //afficher un 0 avant le chiffre
      u8g2.print("0");   //si le chiffre est en 0 et 9
    }
    u8g2.print(angles_max);
    u8g2.write(0xB0);//afficher le signe degree
    //----------------------------------------------GAUGE_INCLINAISON
    u8g2.drawBox(64, 50, 4, 14); //ligne au millieu
    if (directions == 0 && angles > 2) { //bar si penche a gauche
      if (angles < 48) {
        u8g2.drawBox((62 - angles), 52, angles, 10);
      }
      else {
        u8g2.drawBox (12, 52, 50, 10);
      }
    }
    else if (directions == 1 && angles > 2 ) { //bar si penche a droite
      if (angles < 47) {
        u8g2.drawBox(70, 52, angles, 10);
      }
      else {
        u8g2.drawBox(70, 52, 46, 10);
      }
    }
    //-----------------------------------------------ACC/DEC
    if (accelY < 0) { //acceleration
      acc = 0;
    }
    else { //deceleration
      acc = 1;
    }
    acceleration = sqrt(pow(acceleration, 2));//Toujours positif
    //-----------------------------------------------LIGNE ACCELERATION
    u8g2.drawBox(118, 60, 10, 4);
    if (/*acceleration > 1 &&*/ acc == 1) {
      u8g2.drawBox(121, (62 - acceleration), 4, acceleration);
    }
    //-----------------------------------------------LIGNE DECELERATION
    u8g2.drawBox(0, 60, 10, 4);
    if (/*acceleration > 1 &&*/ acc == 0) {
      u8g2.drawBox(3, (62 - acceleration), 4, acceleration);
    }
    //-----------------------------------------------BLUETOOTH
    u8g2.setFont(u8g2_font_5x7_tf); //police
    if (central) {
      u8g2.setCursor(62, 7);
      u8g2.print("BLE connected");
      updateBluetooth();
    }
    else {
      u8g2.setCursor(42, 7);
      u8g2.print("BLE not connected");
    }
    //----------------------------------------------DEBUGG
    /*u8g2.setFont(u8g2_font_5x7_tf);*/
    /*u8g2.setCursor(30, 7);
    u8g2.print(accelY);*/
    /*u8g2.setCursor(60, 7);
    u8g2.print(accelY);  */
    /*u8g2.setCursor(30, 7);
    u8g2.print(mode);*/
    //-----------------------------------------------
  } while ( u8g2.nextPage() );
}
/*-------------------------------------------------------------------------------------------------------------*//*-------------------------------------------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------------------------------------------*//*-------------------------------------------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------------------------------------------*//*-------------------------------------------------------------------------------------------------------------*/
void doCalculations() {
  accRoll = atan2(accelY, accelZ) * 180 / M_PI;
  accPitch = atan2(-accelX, sqrt(accelY * accelY + accelZ * accelZ)) * 180 / M_PI;

  //Correction du bug
  accPitch = accPitch * -1; //car acc et - et gyro +

  float lastFrequency = (float) 1000000.0 / lastInterval;
  gyroRoll = gyroRoll + (gyroX / lastFrequency);
  gyroPitch = gyroPitch + (gyroY / lastFrequency);
  gyroYaw = gyroYaw + (gyroZ / lastFrequency);

  gyroCorrectedRoll = gyroCorrectedRoll + ((gyroX - gyroDriftX) / lastFrequency);
  gyroCorrectedPitch = gyroCorrectedPitch + ((gyroY - gyroDriftY) / lastFrequency);
  gyroCorrectedYaw = gyroCorrectedYaw + ((gyroZ - gyroDriftZ) / lastFrequency);

  complementaryRoll = complementaryRoll + ((gyroX - gyroDriftX) / lastFrequency);
  complementaryPitch = complementaryPitch + ((gyroY - gyroDriftY) / lastFrequency);
  complementaryYaw = complementaryYaw + ((gyroZ - gyroDriftZ) / lastFrequency);

  accelY = accelY-offset_acc;

  if(complementaryPitch < 3 && complementaryPitch > -3){ //Correction de l'angle avec acc quand on est droit
    complementaryRoll = 0.95 * complementaryRoll + 0.05 * accRoll ;
    complementaryPitch = 0.95 * complementaryPitch + 0.05 * (accPitch-offset_angles_pitch);
  }
}

void updateBluetooth() {
  float x, y, z;

  if (IMU.accelerationAvailable()) {
    IMU.readAcceleration(x, y, z);
    String accelerometerData = String(x) + "|" + String(y) + "|" + String(z);
    Serial.println(accelerometerData);
    firstCharacteristic.writeValue(accelerometerData);
  }
}

void getoffset(){
  offset_angles_pitch = accPitch;
  offset_acc = accelY;
}

void calibrateIMU(int delayMillis, int calibrationMillis) {
  int calibrationCount = 0;
  delay(delayMillis); // to avoid shakes after pressing reset button
  float sumX, sumY, sumZ;
  int startTime = millis();
  while (millis() < startTime + calibrationMillis) {
    if (readIMU()) {
      // in an ideal world gyroX/Y/Z == 0, anything higher or lower represents drift
      sumX += gyroX;
      sumY += gyroY;
      sumZ += gyroZ;

      calibrationCount++;
    }
  }
  if (calibrationCount == 0) {
    //Serial.println("Failed to calibrate");
  }
  gyroDriftX = sumX / calibrationCount;
  gyroDriftY = sumY / calibrationCount;
  gyroDriftZ = sumZ / calibrationCount;
}

bool readIMU() {
  if (IMU.accelerationAvailable() && IMU.gyroscopeAvailable() ) {
    IMU.readAcceleration(accelX, accelY, accelZ);
    IMU.readGyroscope(gyroX, gyroY, gyroZ);
    return true;
  }
  return false;
}
